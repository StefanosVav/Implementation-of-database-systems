Η εργασία είναι των Στέφανος Βάβουλας, Δημήτρης Ντάτσης

---------------------------------------------- Για την εκτέλεση --------------------------------------------------------
Στο φάκελο code:
> make sht
> ./build/runner

----------------------------------------- Πληροφορίες για τις δομές ----------------------------------------------------

-- Πίνακας αρχείων(HT Index): πίνακας πρωτευόντων αρχείων, για κάθε θέση τους περιλαμβάνει τις εξής πληροφορίες: 
free (Είναι ελεύθερη ή κατειλημένη η συγκεκριμένη θέση?), 
globaldepth (βάθος του συγκεκριμένου αρχείου), 
anagn_arx (αναγνωριστικό του συγκεκριμένου αρχείου)
onoma_arxeiou (το όνομα του αρχείου)

-- Πίνακας αρχείων(SHT Index): πίνακας δευτερευόντων αρχείων, για κάθε θέση τους περιλαμβάνει τις εξής πληροφορίες:
- free (Είναι ελεύθερη ή κατειλημένη η συγκεκριμένη θέση?), 
- globaldepth (βάθος του συγκεκριμένου αρχείου), 
- anagn_arx (αναγνωριστικό του συγκεκριμένου αρχείου)
- onoma_protevontos_arxeiou (όνομα πρωτευόντος αρχείου)
- attrName (πεδίο κλειδί του δευτερεύοντος ευρετηρίου (city, surname ή name)
- attrLength (μήκος της τιμής του πεδίου κλειδιού του δευτερεύοντος ευρετηρίου)

-- Λίστα create requests(Buckets_Ind): Διπλά συνδεδεμένη λίστα που περιέχει nodes με requests της create index για δημιουργία αρχείου. Κρατά τις εξής πληροφορίες:
- filename (όνομα αρχείου)
- protevon_filename (όνομα πρωτεύοντος αρχείου)
- protevon (μεταβλητή που παίρνει τιμή 1 αν το request ήταν για πρωτεύον και 0 αν ήταν για δευτερέυον)
- startingglobaldepth (αρχικό βάθος για το νέο αρχείο)
- attrName (πεδίο κλειδί του δευτερεύοντος ευρετηρίου (city, surname ή name)
- attrLength (μήκος της τιμής του πεδίου κλειδιού του δευτερεύοντος ευρετηρίου)
Κάθε φορά που καλείται η createindex, στο τέλος της λίστας εισάγεται το νέο create request.
Κάθε φορά που καλείται η openindex, ελέγχεται αν υπάρχει στην λίστα σχετικό create request. Αν δεν υπάρχει, το πρόγραμμα σταματά.

Οι δομές αυτές είναι global και απελευθερώνουν την σχετική μνήμη στο τέλος του προγράμματος.


----------------------------------------- Παραδοχές για την υλοποίηση ----------------------------------------------------

- Δεδομένου του περιορισμού της άσκησης ( Ότι δηλαδή όλες οι εγγραφές με το ίδιο πεδίο-κλειδί για το δευτερεύον ευρετήριο θα πρέπει να χωράνε στο ίδιο block), θεωρήσαμε ότι η καλύτερη υλοποίηση
για να πετύχουμε τόσο την λειτουργία του επεκτατού κατακερματισμού στο δευτερεύον ευρετήριο, όσο και την εισαγωγή των μέγιστων δυνατών εγγραφών, ήταν να ξεκινάμε με δυναμική προσέγγιση ( επεκτατό 
κατακερματισμό) την εισαγωγή (ίδια με την εισαγωγή στο πρωτεύον ευρετήριο), αλλά, κατά τον διπλασιασμό των buckets όπου ο αριθμός τους ξεπεράσει τον αριθμό των τιμών του πεδίου-κλειδιού για το
δευτερεύον ευρετήριο ( στη δική μας περίπτωση τις 14 πόλεις που δίνονται), μετατρέπουμε υποχρεωτικά την υλοποίηση σε στατικό κατακερματισμό ώστε να καλύψουμε τον περιορισμό της άσκησης ( δεν υπάρχει
δηλαδή πλέον δυνατότητα νέου διπλασιασμού των buckets καθώς κάθε πεδίο-κλειδί(πόλη) αντιστοιχεί σε ένα μόνο bucket του δευτερεύοντος ευρετηρίου). 
Επιπλέον, στο τελευταίο αυτό βήμα, μετατρέπουμε τον τρόπο αποθήκευσης των εισαγωγών στο δευτερέυον δέντρο από |πεδίο-tupleID, πεδίο-tupleID...| σε |tupleID, tupleID...| εφόσον κάθε πεδίο αντιστοιχεί
πλέον σε ένα μόνο bucket όπως αναφέραμε οπότε δεν χρειάζεται να αποθηκέυουμε πλέον το πεδίο μαζί με το tupleID. Αυτή η μετατροπή γίνεται για να χωράει ο μέγιστος αριθμός εγγραφών. 
- Προκειμένου να υλοποιηθεί η ζεύξη σε ένα κοινό πεδίο δευτερευόντων ευρετηρίων(πόλη), δημιουργούμε στη main 2 πρωτεύοντα αρχεία/ευρετήρια και 2 δευτερέυοντα που αντιστοιχούν στα πρώτα, ώστε να έχουμε 
2 διαφορετικά δευτερεύοντα ευρετήρια για τη ζέυξη.


----------------------------------------- Αναλυτικά για την υλοποίηση ----------------------------------------------------

main (sht_main.c): 
1. Δημιουργούνται 2 πρωτεύοντα αρχεία επεκτατού κατακερματισμού (ΗΤ).
2. Δημιουργούνται 2 δευτερεύοντα αρχεία επεκτατού κατακερματισμού στο πεδίο city (SHT) που αντιστοιχούν στα πρωτεύοντα .
3. Εισάγονται σε κάθε ζευγάρι πρωτέυον-δευτερεύον (HT, SHT) RECORDS_NUM(=500) εγγραφές.
4. Για κάθε πρωτεύον αρχείο, εκτυπώνονται όλες οι εγγραφές που πληρούν κάποιο κριτήριο ως προς το πεδίο-κλειδί (id). Συγκεκριμένα τυπώνονται όλες οι εγγραφές με 750 < id < 1000.
5. Για κάθε δευτερέυον αρχείο, εκτυπώνονται όλες οι εγγραφές που πληρούν κάποιο κριτήριο ως προς το πεδίο city, στο οποίο έγινε η ευρετηρίαση στο δευτερεύον ευρετήριο. Συγκεκριμένα εκτυπώνουμε όλες
τις εγγραφές με πεδίο city = Athens.
6. Εισάγονται σε κάθε ζευγάρι πρωτέυον-δευτερεύον (HT, SHT) ακόμα RECORDS_NUM(=500) εγγραφές.
7. Εκτελούνται πάλι τα βήματα 4,5 μετά την εισαγωγή των νέων εγγραφών.
8. Εκτελείται η InnerJoin και εκτυπώνεται το καρτεσιανό γινόμενο των εγγραφών των 2 δευτερευόντων ευρετηρίων που μοιράζονται την ίδια τιμή στο πεδίο-κλειδί τους (city), συγκεκριμένα city = Athens.
9. Εκτυπώνονται τα στατιστικά.

HT_InsertEntry (hash_file.c): 
Έχει ανανεωθεί ώστε να επιστρέφει το tupleID για την νέα εισαγωγή με το οποίο θα εισαχθεί στο δευτερέυον ευρετήριο, να ανανεώνονται τα tupleIDs (με την SecondaryUpdateEntry) 
κατά την επαναεισαγωγή όταν γίνεται σπάσιμο των buddies, και επιπλέον, να ανανεώνονται τα tupleIDs (με την SecondaryUpdateEntry) κατά το διπλασιασμό των buckets στο πρωτεύον ευρετήριο, όπου απαιτείται
επαναεισαγωγή όλων των εγγραφών για την σωστή κατανομή των εισαγωγών στο πρωτεύον ευρετήριο και αντίστοιχα σωστή ανανέωση των tupleIDs στο δευτερέυον. 
Επίσης, κατα τις επαναεισαγωγές, θέτει τις καταλληλες τιμές στα πεδία oldTupleID, newTupleID του updateRecordArray struct το οποίο χρησιμοποιείται για την κλήση της SecondaryUpdateEntry.

SHT_SecondaryInsertEntry(sht_file.c): 
Όπως αναφέραμε και προηγουμένως, για την εισαγωγή στο δευτερέυον ευρετήριο υπάρχουν δύο περιπτώσεις. 
Στην πρώτη περίπτωση, όπου έχουμε ακόμα δυναμικές εισαγωγές (επεκτατό κατακερματισμό), το hashing, οι εισαγωγές, το σπάσιμο των buddies και ο διπλασιασμός γίνονται όμοια με την Insert στο 
πρωτεύον ευρετήριο, μέχρι ο διπλασιασμός να μας οδηγήσει σε αριθμό buckets μεγαλύτερο από τον αριθμό των τιμών του πεδίου-κλειδιού. Τότε, η υλοποίηση μετατρέπεται σε στατικό κατακερματισμό και έχουμε
Tη δεύτερη περίπτωση, όπου η νέα εισαγωγή τοποθετείται στο bucket που κρατάει τις εισαγωγές με την συγκεκριμένη τιμή στο πεδίο-κλειδί. Το πρόγραμμα τερματίζει αν προσπαθήσει να εισαχθεί σε ένα τέτοιο
bucket εισαγωγή που ξεπερνάει τον χώρο του bucket.

SHT_SecondaryUpdateEntry(sht_file.c): 
Χρησιμοποιώντας το updateRecordArray struct στο οποίο έχουν τεθεί κατάλληλα οι τιμές oldTupleID, newTupleID κατα τις επαναεισαγωγές στην HT_Insert, ελέγχει αν
οι δύο αυτές τιμές είναι ίσες, και, αν όχι, ανανεώνει το tupleID της εισαγωγής με το newTupleID.

SHT_PrintAllEntries(sht_file.c): 
Ζητάται μία τιμή πεδίου-κλειδιού, βρίσκει το bucket στο οποίο θα άνηκε μία εγγραφή με τη συγκεκριμένη τιμή και εκτυπώνει τις εγγραφές που έχουν αυτή την τιμή.

SHT_InnerJoin(sht_file.c):
Δίνονται δύο αρχεία και η τιμή του πεδίου-κλειδιού πάνω στην οποία θα γίνει η InnerJoin. Για κάθε αρχείο έχουμε την περίπτωση το δευτερεύον ευρετήριο να είναι στατικό (περίπτωση Α) ή δυναμικό (περίπτωση Β).
Ανάλογα με τις δύο παραπάνω περιπτώσεις έχουμε 4 συνδυασμούς περιπτώσεων για την InnerJoin( AA, BB, AB, BA) όπου στα στατικά ευρετήρια, εκεί δηλαδή που κάθε bucket αντιστοιχεί σε μία μόνο τιμή του
πεδίου-κλειδιού, παίρνουμε όλες τις εισαγωγές του bucket, ενώ, στα δυναμικά ευρετήρια, εξετάζουμε κάθε εισαγωγή του bucket που μας επιστρέφει η hash function και κρατάμε μόνο αυτές όπου η τιμή του 
πεδίου-κλειδιού είναι αυτή που αναζητείται.
Στη συνέχεια, εκτυπώνουμε το καρτεσιανό γινόμενο των εγγραφών που έχουμε κρατήσει απο τα δύο αρχεία, δηλαδή, για κάθε εγγραφή του πρώτου αρχείου εκτυπώνουμε τα ζεύγη αυτής της εγγραφής με κάθε
εγγραφή του δεύτερου αρχείου.


------------------------------------------- Εκτύπωση αποτελεσμάτων -----------------------------------------------------

Output1.txt: Οι εισαγωγές στο δευτερεύον αρχείο. Στο τέλος του αρχείου έχουμε την printAllEntries για το δευτερεύον, δηλαδή εκτυπώσεις των εγγραφών των 2 δευτερευόντων αρχείων που πληρούν κάποιο κριτήριο 
ως προς το πεδίο-κλειδί (city = Athens) και την εκτύπωση του καρτεσιανού γινομένου της InnerJoin
All_Entries.txt: Oι εκτυπώσεις των εγγραφών των 2 πρωτευόντων αρχείων που πληρούν κάποιο κριτήριο ως προς το πεδίο-κλειδί (id)
Hash_Stats.txt: Τα στατιστικά για τα πρωτεύοντα αρχεία
Output.txt: Οι εισαγωγές στο πρωτεύον αρχείο ( απλές εισαγωγές, σπασίματα buddies, διπλασιασμοί buckets, rehashing) 

